using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MFToolkit.AutoGenerator.JsonContextGenerate;
/// <summary>
/// 自动注入生成器
/// </summary>
[Generator(LanguageNames.CSharp)]
public class AutoJsonContextGenerate : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(c => c.AttributeLists.Count > 0);
        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, (spc, source) =>
        {
            var assName = source.Left.AssemblyName;
            Execute(source.Left, source.Right, spc, assName);
        });
    }

    private void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context, string? AssemblyName)
    {
        if (classes.IsDefaultOrEmpty) return;

        var registrations = new List<ServiceRegistration>();
        var attributeSymbol = compilation.GetTypeByMetadataName("MFToolkit.Abstractions.JsonContextGenerate.AutoJsonGenerateAttribute`1");
        var nonGenericAttributeSymbol = compilation.GetTypeByMetadataName("MFToolkit.Abstractions.JsonContextGenerate.AutoJsonGenerateAttribute");
        var nameSpaceAttributeSymbol = compilation.GetTypeByMetadataName("MFToolkit.Abstractions.JsonContextGenerate.AutoJsonGenerateNameAttribute");
        string? serviceName = null;
        foreach (var classDecl in classes.Distinct())
        {
            var model = compilation.GetSemanticModel(classDecl.SyntaxTree);

            if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol || classSymbol.IsAbstract || classSymbol.IsStatic) continue;

            var attributes = classSymbol.GetAttributes()
                .Where(a => a.AttributeClass != null &&
                    (a.AttributeClass.OriginalDefinition?.Equals(attributeSymbol, SymbolEqualityComparer.Default) == true ||
                     a.AttributeClass.Equals(nonGenericAttributeSymbol, SymbolEqualityComparer.Default)))
                .ToList();

            var namespaceAttributes = classSymbol.GetAttributes()
                .Where(a => a.AttributeClass != null &&
                    a.AttributeClass.Equals(nameSpaceAttributeSymbol, SymbolEqualityComparer.Default))
                .FirstOrDefault();

            if (namespaceAttributes != null)
            {
                if (classSymbol.ContainingNamespace.ToDisplayString().Contains(AssemblyName))
                {
                    // 获取命名空间属性和服务注入名称
                    serviceName = namespaceAttributes.ConstructorArguments[0].Value?.ToString();
                }
            }

            foreach (var attribute in attributes)
            {
                var registration = ParseAttribute(classSymbol, attribute, AssemblyName);
                if (registration != null)
                {
                    registrations.Add(registration);
                }
            }
        }

        GenerateSource(context, registrations, serviceName);
    }


    private ServiceRegistration? ParseAttribute(INamedTypeSymbol classSymbol, AttributeData attribute, string? nameSpace)
    {
        // 优先从泛型属性中获取服务类型
        ITypeSymbol? generateType = null;

        // 处理泛型 AutoInjectAttribute<T> 和 AutoTryInjectAttribute<T>
        if (attribute.AttributeClass?.IsGenericType == true &&
            (attribute.AttributeClass.Name == "AutoJsonGenerateAttribute"))
        {
            generateType = attribute.AttributeClass.TypeArguments[0];
        }
        else
        {
            // 处理非泛型 AutoInjectAttribute 或旧逻辑
            generateType = GetServiceType(attribute);
            //debugInfo = attribute.ToString(); // 获取调试信息
        }

        // 默认回退到实现类型
        generateType ??= classSymbol;

        var serviceKey = GetServiceKey(attribute);
        string targetNamespace = nameSpace != null ? nameSpace + ".JsonContexts" : GetTargetNamespace(classSymbol.ContainingNamespace.ToDisplayString());

        return new ServiceRegistration(
            generateType,
            targetNamespace
        );
    }

    private static string GetTargetNamespace(string originalNamespace)
    {
        // 分割命名空间层级（如 ["Demo", "DemoModel"]）
        var parts = originalNamespace.Split('.');
        if (parts.Length == 0) return "MFToolkit.AutoJsonContexts"; // 根命名空间处理
        // 提取父级命名空间（去掉最后一级）并拼接 "AutoGenerated"
        var parentNamespace = parts[0];
        return string.IsNullOrEmpty(parentNamespace)
            ? "MFToolkit.AutoJsonContexts"
            : $"{parentNamespace}.JsonContexts";
    }


    private static ITypeSymbol? GetServiceType(AttributeData attribute)
    {
        // 处理非泛型属性中的 Type 参数（例如 [AutoInject(typeof(IService))]）
        foreach (var arg in attribute.ConstructorArguments)
        {
            if (arg.Value is ITypeSymbol typeSymbol)
            {
                return typeSymbol;
            }
        }
        return null;
    }


    //private static string? GetServiceKey(AttributeData attribute)
    //{
    //    if (attribute.ConstructorArguments.Length > 1 &&
    //        attribute.ConstructorArguments[1].Value is string key)
    //    {
    //        return key;
    //    }
    //    return null;
    //}

    private static string? GetServiceKey(AttributeData attribute)
    {
        // 检查是否有 string 参数
        foreach (var arg in attribute.ConstructorArguments)
        {
            if (arg.Value is string key)
            {
                return key;
            }
        }
        return null;
    }



    private void GenerateSource(
    SourceProductionContext context,
    IEnumerable<ServiceRegistration> registrations,
    string? generateClassName
)
    {
        // 按目标命名空间分组
        var groupedRegistrations = registrations
            .GroupBy(r => r.TargetNamespace)
            .ToList();

        foreach (var group in groupedRegistrations)
        {
            string targetNamespace = group.Key; // 如 "Demo.AutoGenerated"
            var registrationsInGroup = group.ToList();

            // 生成代码模板
            var source = $@"
// <auto-generated/>

// Bug Issue: https://github.com/MoFeng-02/MFToolkit/issues

namespace {targetNamespace}
{{

    /// <summary>
    /// 本类为生成器生成，用于自动生成Json上下文
    /// </summary>
    [global::System.Text.Json.Serialization.JsonSourceGenerationOptions(
                   PropertyNamingPolicy = global::System.Text.Json.Serialization.JsonKnownNamingPolicy.CamelCase,
                   DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
    {BuildRegistrationCode(registrationsInGroup).Replace("\n", "\n    ")}
    public partial class {generateClassName ?? "GenerateJsonContext"} : global::System.Text.Json.Serialization.JsonSerializerContext{{}}
}}";

            // 生成文件名（如 "Demo.AutoGenerated.AutoInject.g.cs"）
            string fileName = $"{targetNamespace}.AutoInject.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }


    private static string BuildRegistrationCode(IEnumerable<ServiceRegistration> registrations)
    {
        var sb = new StringBuilder();

        foreach (var reg in registrations)
        {
            var generateType = reg.GenerateType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var line =  BuildNormalServiceLine( generateType);
            sb.AppendLine(line);
        }
        return sb.ToString();
    }

    private static string BuildNormalServiceLine(string generateType)
    {
        var str = $"[global::System.Text.Json.Serialization.JsonSerializable(typeof({generateType}))]";
        return str;
    }

    private class ServiceRegistration(
        ITypeSymbol generateType,
        string targetNamespace)
    {
        /// <summary>
        /// 生成类型
        /// </summary>
        public ITypeSymbol GenerateType { get; set; } = generateType;
        public string TargetNamespace { get; } = targetNamespace; // 新增属性
    }
}
